// This is your Prisma schema file:
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// basic idea: here you define your local prisma data models which you can use across your app to read and write data on your (remote) database
// prisma synchronizes your defined local data models with your remote database. Anytime you change anything that affects the data models, run the command "npx prisma db push" to synchronize your local data models with your remote database.

// specify how Prisma should generate the client for your project
generator client {
  provider = "prisma-client-js"
}

// specify the details of the database that Prisma ORM should connect to, to synchronize your local data models with- and perform actions on the (remote) DB
datasource db {
  provider = "postgresql"
  // PostgreSQL remote database (from Neon) 
  url      = env("DATABASE_URL")
}

// enum type is a list of valid entries
enum OrderStatus {
  fulfilled
  shipped
  awaiting_shipment
}

enum PhoneModel {
  iphonex
  iphone11
  iphone12
  iphone13
  iphone14
  iphone15
}

enum CaseMaterial {
  silicone
  polycarbonate
}

enum CaseFinish {
  smooth
  textured
}

enum CaseColor {
  black
  blue
  rose
}

// data models (tables)
model Configuration {
  // each new object gets an id from the 'cuid' function
  // the @id attribute designates the field as the primary key of the table
  id              String        @id @default(cuid())
  width           Int
  height          Int
  imageUrl        String
  // optional field (won't be initialized in step 1, only until step 2)
  croppedImageUrl String?
  // only the values from the enum types are allowed in these fields
  model           PhoneModel?
  material        CaseMaterial?
  finish          CaseFinish?
  color           CaseColor?
  // store order entries (indicates that a single Configuration can be linked to multiple order entries)
  Order           Order[]
}

model User {
  // primary key (each record has a unique id)
  id    String  @id @default(cuid())
  email String
  // store order entries (indicates that a single User can be linked to multiple order entries)
  Order Order[]

  createdAt DateTime @default(now())
  // automatically stores when this entry / record was last updated
  updatedAt DateTime @updatedAt
}

model ShippingAddress {
  // primary key (each record has a unique id)
  id          String  @id @default(cuid())
  name        String
  street      String
  city        String
  postalCode  String
  country     String
  state       String?
  phoneNumber String?
  // store order entries (indicates that a single ShippingAddress can be linked to multiple order entries)
  orders      Order[]
}

model BillingAddress {
  // primary key (each record has a unique id)
  id          String  @id @default(cuid())
  name        String
  street      String
  city        String
  postalCode  String
  country     String
  state       String?
  phoneNumber String?
  // store order entries (indicates that a single ShippingAddress can be linked to multiple order entries)
  orders      Order[]
}

model Order {
  // primary key (each record has a unique id)
  id        String      @id @default(cuid())
  amount    Float
  isPaid    Boolean     @default(false)
  // the default value for order 'status' is "awaiting_shipment"
  status    OrderStatus @default(awaiting_shipment)
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  // foreign key stores the ID of the related 'Configuration' record and establishes the relationship between the two models 'Order' & 'Configuration'
  // this indicates that each Order is linked to one specific Configuration
  configurationId String
  // foreign key 'configurationId' refers to the primary key 'id' from the table 'Configuration', which defines a relationship between the tables 'Order' & 'Configuration'
  // one-to-many relationship: One Configuration can be associated with many Orders ('Order[]'), but each Order is associated with one Configuration (FK)
  configuration   Configuration @relation(fields: [configurationId], references: [id])

  // foreign key stores the ID of the related 'User' record
  userId String
  // one-to-many relationship: One User can be associated with many Orders ('Order[]'), but each Order is associated with one User (FK 'userId')
  User   User   @relation(fields: [userId], references: [id])

  // foreign key stores the ID of the related 'ShippingAddress' record
  shippingAddressId String?
  // one-to-many relationship: One ShippingAddress can be associated with many Orders ('Order[]'), but each Order is associated with one ShippingAddress (FK)
  shippingAddress   ShippingAddress? @relation(fields: [shippingAddressId], references: [id])

  // foreign key stores the ID of the related 'BillingAddress' record
  billingAddressId String?
  // one-to-many relationship: One BillingAddress can be associated with many Orders ('Order[]'), but each Order is associated with one BillingAddress (FK)
  billingAddress   BillingAddress? @relation(fields: [billingAddressId], references: [id])
}
